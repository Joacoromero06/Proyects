%option noyywrap nodefault yylineno


%x IFILE

UCN (\\u[0-9a-fA-F]{4}|\\U[0-9a-fA-F]{8})

EXP ([Ee][-+]?[0-9]+)

ILEN ([Uu](L|l|LL|ll)?|(L|l|ll|LL)[Uu]?)

%{

struct symbol{
    char* name;
    struct ref* reflist;
};
struct ref {
    struct ref* next;
    int flag;
    int lineno;
    char* filename;
};
#define NHASH 9997
struct symbol symtab[NHASH];
struct symbol* lookup(char*);
void addref(int, char*, char*, int);
void printrefs();
char* curfilename;

struct bufstack{
    YY_BUFFER_STATE bs;
    struct bufstack* prev;
    int lineno;
    char* filename;
    FILE* f;
};
struct bufstack* curr_bs;
int pushfile(char*);
int popfile();

int defining;

%}

%%




"//".* 

_Bool |
_Imaginary |
_Complex |
auto |
char |
extern |
const |
double |
enum |
float |
inline |
int |
long |
register |
restrict |
short |
signed |
static |
struct |
union |
typedef |
void |
volatile {defining = 1;}

breal |
continue |
default |
do |
else |
for |
goto |
if |
return |
sizeof |
swhich |
while |

0[0-7]*{ILEN}?
[1-9][0-9]*{ILEN}?
0[Xx][0-9a-fA-F]+{ILEN}?

([0-9]*\.[0-9]+|[0-9]+\.){EXP}?[flFL]?
[0-9]+{EXP}[flFL]?

0[xX]([0-9a-fA-f]*\.[0-9a-fA-f]+\[0-9a-fA-f]\.)[Pp][-+]?[0-9]+[flFL]?

\'([^'\\]|\\['"?\\abfnrtv]|\\[0-7]{1,3}|\\[xX][0-9a-fA-F]+|{UCN})+\'
L?\"([^"\\]|\\['"?\\abfnrtv]|\\[0-7]{1,3}|\\[xX][0-9a-fA-F]+|{UCN})*\"

"{"|";"|"<%" {defining = 0;}

"["|"]"|"("|")"|"{"|"}"|"."|"->"
"++"|"--"|"&"|"*"|"+"|"-"|"~"|"!"
"/"|"%"|"<<"|">>"|"<"|">"|"<="|">="|"=="|"!="|"^"|"|"|"&&"|"||"
"?"|":"|";"|"..."
"="|"*="|"/="|"%="|"+="|"-="|"<<="|">>="|"&="|"^=""|="
","|"#"|"##"
"<:"|":>"|"%>"|"%:"|"%:%:"

([_a-zA-Z]|{UCN})([_a-zA-Z0-9]|{UCN})* {
                            addref(yylineno, curfilename, yytext, defining);}
[ \t\n]+
\\$
"#"" "*if.*\n
"#"" "*else.*\n
"#"" "*endif.*\n
"#"" "*define.*\n
"#"" "*line.*\n

^"#"[ \t]*include[ \t]*[\"<] {BEGIN(IFILE);}
<IFILE>[^>\"]+ {
                int c;
                while( (c=input()) && c!= '\n' );
                pushfile(strdup(yytext));
                BEGIN(INITIAL);
                }
<IFILE>.|\n {fprintf(stderr, "%s: %d. directiva include erronea.\n",
                     curfilename, yylineno); BEGIN(INITIAL);}

        
<<EOF>> {printf("FIN ARCHIVO \n");
        if( !popfile() ){yyterminate();}}
. {printf("%s: %d. caracter misterioroso %s\n", curfilename, yylineno, yytext);}

%%

int main(int argc, char** argv){
    int i;    
    if(argc < 2){
        fprintf(stderr, "se necesita nombre de archivo\n");
        return 1;
    }
    for(i = 1; i<argc; i++){
        if(pushfile(argv[i]))
            yylex();
        curr_bs = NULL;
    }
    printf("salio del for \n ");            
    printrefs();
    return 0;
}

static unsigned symhash(char* sym){
    unsigned int c, hash = 0;
    
    while( (c= *sym) != '\0' ){
        hash = hash * 9 ^ c;
        sym ++;
    }

    return hash;
}

struct symbol* lookup(char* sym){
    struct symbol* sp = &symtab[symhash(sym)%NHASH];
    int scount = NHASH - 1;

    while(scount >= 0){
        if(sp->name && !strcmp(sym, sp->name))
            return sp;
        if(!sp->name){
            sp->name = strdup(sym);
            sp->reflist = NULL;
            return sp;
        }           
        if(sp == &symtab[NHASH-1]) 
            sp = symtab;
        else
            sp ++;
        scount --;
    }
    fputs("Error fatal: tabla llena\n", stderr);
    abort();
}

void addref(int lineno, char* filename, char* word, int flag){
    struct ref* r;
    struct symbol* sp = lookup(word);

    if(sp->reflist &&
        sp->reflist->lineno == lineno &&
        !strcmp(sp->reflist->filename, filename) )
        return;
    
    r = malloc(sizeof(struct ref));
    if(!r){
        fputs("Error fatal: sin memori\n", stderr);
        abort();
    }
    r->next = sp->reflist;
    r->lineno = lineno;
    r->flag = flag;
    r->filename = strdup(filename);
    sp->reflist = r;
}

static int symcompare(const void* xa, const void* xb){
    const struct symbol* a = (const struct symbol*) xa;
    const struct symbol* b = (const struct symbol*) xb;

    if(!a->name){
        if(!b->name){
            return 0;
        }
        return 1;
    }
    if(!b->name)
        return -1;
    return strcmp(a->name,b->name);
}

void printrefs(){
    struct symbol* sp;
    qsort(symtab, NHASH, sizeof(struct symbol), symcompare);

    for(sp = symtab; sp->name && sp < symtab + NHASH; sp++){
        char* prevfn = NULL;

        struct ref* rp = sp->reflist;
        struct ref* rpp = NULL;
        struct ref* rnp;

        do {
            rnp = rp->next;
            rp->next = rpp;
            rpp = rp;
            rp = rnp;
        }while(rp);

        printf("%10s", sp->name);
        for( rp = rpp; rp; rp = rp->next ){
            if(rp->filename == prevfn)
                printf(" %d", rp->lineno);
            else{
                printf(" %s: %d", rp->filename, rp->lineno);
                prevfn = rp->filename;
            }
            if (rp->flag & 01) printf("*");
        }
        printf("\n");
    }
}

int pushfile(char *fn) {
    FILE *f = fopen(fn, "r");
    if (!f) { perror(fn); return 0; }

    struct bufstack* pila = malloc(sizeof(struct bufstack));
    if (!pila) { perror("malloc"); exit(1); }

    fprintf(stdout, "=======Entrando al archivo: %s=======\n", fn);

    if (curr_bs)
        curr_bs->lineno = yylineno;

    pila->prev = curr_bs;
    pila->f = f;
    pila->filename = strdup(fn);
    pila->bs = yy_create_buffer(f, YY_BUF_SIZE);

    yy_switch_to_buffer(pila->bs);
    curr_bs = pila;
    yylineno = 1;
    printf("curfilename antes: %s\n", curfilename);
    curfilename = strdup(pila->filename);
    printf("curfilename despues: %s\n", curfilename);

    return 1;
}

int popfile(void) {
    if (!curr_bs){ printf("curr_bs es NULL al intentar hacer pop");return 0;}
    fprintf(stdout, "\n=======Saliendo del archivo: %s=======\n", curr_bs->filename);


    struct bufstack* pila = curr_bs;
    struct bufstack* prev = pila->prev;
    printf("1\n");
    fclose(pila->f);
    yy_delete_buffer(pila->bs);
    free(pila->filename);
    free(pila);
    printf("2\n");
    if (!prev){
        printf("prev es NULL al intentar hacer pop\n");
        return 0; 
    }
    curr_bs = prev;
    printf("3\n ");
    yy_switch_to_buffer(prev->bs);
    printf("4\n ");
    yylineno = prev->lineno;
    curfilename = prev->filename;
    return 1;
}



